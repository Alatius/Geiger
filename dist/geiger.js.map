{"version":3,"sources":["geiger.js"],"names":["Action","Store","args","dispatching","waiting","emit","cbk","on","removeListener","length","actions","event","Error","constructor","name","push","res","ispromise","then","isWaiting","dispatchingEnd","pop","console","log","waitFor","stores","promises","Array","isArray","map","store","isDispatching","Promise","once","resolve","all","ContextFactory","propTypes","propname","props","render","childContextTypes"],"mappings":"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","file":"geiger.js","sourcesContent":["'use strict';\n\nimport { Component } from 'react';\nimport { EventEmitter } from 'events';\n\nexport class Action extends EventEmitter { }\n\nexport class Store extends EventEmitter {\n\n    constructor(...args) {\n        super(...args);\n        this.dispatching = [];\n        this.waiting = [];\n    }\n\n    changed() { this.emit('change'); }\n\n    watch(cbk) {\n        this.on('change', cbk);\n        return () => this.removeListener('change', cbk);\n    }\n\n    isDispatching() { return this.dispatching.length > 0; }\n\n    isWaiting() { return this.waiting.length > 0; }\n\n    listen(actions, event, cbk) {\n\n        if(typeof actions !== 'object' || typeof actions.on !== 'function') { throw new Error('Store ' + this.constructor.name + '.listen() method expects an EventEmitter-compatible object as a first parameter.'); }\n\n        actions.on(event, (...args) => {\n\n            // dispatching begins\n            this.dispatching.push(event);\n\n            const res = cbk(...args);\n            const ispromise = (typeof res === 'object' && typeof res.then === 'function');\n\n            if(this.isWaiting() && !ispromise) { throw new Error('Store ' + this.constructor.name + ' waiting; action has to return the waiting promise (the promise returned by waitFor).'); }\n\n            const dispatchingEnd = () => {\n                this.dispatching.pop();\n                this.emit('dispatching:end', event);\n                // dispatching ends\n            };\n\n            if(ispromise) {\n                res.then(dispatchingEnd);\n            } else {\n                dispatchingEnd();\n            }\n\n            return res;\n        });\n    }\n\n    wait(...args) {\n        console.log('Geiger: wait() is deprecated in favour of waitFor(). Please, update your codebase.');\n        return this.waitFor(...args);\n    }\n\n    waitFor(stores) {\n\n        this.waiting.push(true);\n\n        const promises = [];\n\n        (Array.isArray(stores) ? stores : [stores]).map(store => {\n            if(store.isDispatching()) {\n                promises.push(new Promise(resolve => store.once('dispatching:end', resolve)));\n            } else { promises.push(true); }\n        });\n\n        return Promise.all(promises).then(() => this.waiting.pop());\n    }\n}\n\nexport const ContextFactory = (propTypes) => {\n\n    return class FactoriedContext extends Component {\n\n        static childContextTypes = propTypes;\n        static propTypes = propTypes;\n\n        getChildContext() {\n            const res = {};\n            for(let propname in propTypes) { res[propname] = this.props[propname]; }\n            return res;\n        }\n\n        render() { return this.props.render(); }\n    };\n\n};\n"],"sourceRoot":"/source/"}